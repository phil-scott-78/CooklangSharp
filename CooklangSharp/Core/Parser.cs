using System.Globalization;
using System.Text;
using CooklangSharp.Models;

namespace CooklangSharp.Core;

/// <summary>
/// The Parser consumes the stream of tokens generated by the Lexer and builds the
/// structured, hierarchical representation of the recipe (an Abstract Syntax Tree).
/// </summary>
public class Parser
{
    private List<Token> _tokens = [];
    private List<Diagnostic> _diagnostics = [];
    private int _position;

    /// <summary>
    /// Gets the current token without consuming it.
    /// </summary>
    private Token Current => _position < _tokens.Count ? _tokens[_position] : _tokens.Last();

    /// <summary>
    /// Consumes the current token and moves to the next one.
    /// </summary>
    private void Advance()
    {
        if (_position < _tokens.Count) _position++;
    }

    /// <summary>
    /// The main entry point for the parser. It orchestrates the entire parsing process.
    /// </summary>
    public ParseResult ParseRecipe(string source)
    {
        try
        {
            if (string.IsNullOrEmpty(source))
            {
                return ParseResult.CreateSuccess(new Recipe());
            }

            // 1. Lexing: Convert raw text into a stream of tokens.
            var lexer = new Lexer(source);
            var (tokens, lexerDiagnostics) = lexer.Tokenize();
            _tokens = tokens;
            _diagnostics = new List<Diagnostic>(lexerDiagnostics);
            _position = 0;

            var recipe = new Recipe();

            // 2. Front Matter: This is handled separately as it's not tokenized.
            var (frontMatter, startIndex) = ExtractFrontMatter(source);
            recipe = recipe with { FrontMatter = frontMatter ?? string.Empty };

            // 3. Parsing: Advance past front matter and parse the recipe body.
            while (Current.Type != TokenType.EndOfStream && Current.Line <= startIndex)
            {
                Advance();
            }

            var sectionsResult = ParseSections();
            recipe = recipe with { Sections = sectionsResult.Sections, Metadata = sectionsResult.ClassicMetadata };

            // 4. Result: Return the completed recipe or any errors found.
            return _diagnostics.Any(d => d.DiagnosticType == DiagnosticType.Error)
                ? ParseResult.CreateError(_diagnostics)
                : ParseResult.CreateSuccess(recipe, _diagnostics);
        }
        catch (Exception ex)
        {
            _diagnostics.Add(new Diagnostic
            {
                Message = $"Unexpected parser error: {ex.Message}", Line = Current.Line, Column = Current.Column,
                Length = 1, Context = Current.Value,
                Type = ParseErrorType.Other, DiagnosticType = DiagnosticType.Error
            });
            return ParseResult.CreateError(_diagnostics);
        }
    }

    /// <summary>
    /// Manually extracts the YAML front matter block from the start of the source text.
    /// </summary>
    /// <returns>The front matter content and the line number where the recipe content begins.</returns>
    private static (string? frontMatter, int startIndex) ExtractFrontMatter(string source)
    {
        var lines = source.Split(ParserConstants.NewLine);
        if (lines.Length == 0 || lines[0].Trim() != ParserConstants.FrontMatterDelimiter) return (null, 0);

        var frontMatterLines = new List<string>();
        var lineIndex = 1;
        while (lineIndex < lines.Length)
        {
            var line = lines[lineIndex];
            if (line.Trim() == ParserConstants.FrontMatterDelimiter)
            {
                lineIndex++;
                break;
            }

            // Remove any trailing \r to handle CRLF line endings properly
            frontMatterLines.Add(line.TrimEnd('\r'));
            lineIndex++;
        }

        return (string.Join(ParserConstants.NewLine, frontMatterLines), lineIndex);
    }

    private void AddDiagnostic(Diagnostic diagnostic) => _diagnostics.Add(diagnostic);

    /// <summary>
    /// Creates and adds a syntax error diagnostic.
    /// </summary>
    private void AddSyntaxError(string message, Token token, ParseErrorType type, int? length = null)
    {
        AddDiagnostic(new Diagnostic
        {
            Message = message,
            Line = token.Line,
            Column = token.Column,
            Length = length ?? token.Value.Length,
            Context = token.Value,
            Type = type,
            DiagnosticType = DiagnosticType.Error
        });
    }

    /// <summary>
    /// Creates and adds a warning diagnostic.
    /// </summary>
    private void AddWarning(string message, Token token, ParseErrorType type, int? length = null)
    {
        AddDiagnostic(new Diagnostic
        {
            Message = message,
            Line = token.Line,
            Column = token.Column,
            Length = length ?? token.Value.Length,
            Context = token.Value,
            Type = type,
            DiagnosticType = DiagnosticType.Warning
        });
    }

    /// <summary>
    /// Looks ahead at the next token without consuming it.
    /// </summary>
    private Token? PeekNextToken(int offset = 1)
    {
        var targetPosition = _position + offset;
        return targetPosition < _tokens.Count ? _tokens[targetPosition] : null;
    }

    /// <summary>
    /// Determines if a newline should end the current step based on the token that follows.
    /// </summary>
    private bool ShouldEndStepAtNewline()
    {
        var nextToken = PeekNextToken();
        if (nextToken == null) return true; // End of input

        // End step if next token indicates a significant boundary
        return nextToken.Type == TokenType.Newline || // Blank line
               nextToken.Type == TokenType.SectionHeader ||
               nextToken.Type == TokenType.Metadata ||
               nextToken.Type == TokenType.Note ||
               nextToken.Type == TokenType.EndOfStream;
    }

    /// <summary>
    /// Determines if a newline should continue the current step by adding a space separator.
    /// </summary>
    private bool ShouldContinueStepAfterNewline()
    {
        var nextToken = PeekNextToken();

        // Continue step if next token is content
        return nextToken?.Type is TokenType.Text or TokenType.At or TokenType.Hash or TokenType.Tilde;
    }

    /// <summary>
    /// Validates that there is no space before a brace in component syntax.
    /// </summary>
    private void ValidateNoSpaceBeforeBrace(Token startToken, string componentType, ParseErrorType errorType)
    {
        if (Current.Type != TokenType.Text || Current.Value.TrimEnd() == Current.Value || PeekNextToken()?.Type != TokenType.LBrace)
        {
            return;
        }

        var spacePosition = Current.Column + Current.Value.TrimEnd().Length;
        AddDiagnostic(new Diagnostic
        {
            Message = $"Invalid {componentType} syntax: space not allowed before '{{'", 
            Line = startToken.Line,
            Column = spacePosition,
            Length = 1, 
            Context = Current.Value,
            Type = errorType, 
            DiagnosticType = DiagnosticType.Error
        });
    }

    /// <summary>
    /// Parses the main body of the recipe, which is composed of sections.
    /// This is the top-level loop after handling front matter.
    /// </summary>
    private SectionsResult ParseSections()
    {
        var sections = new List<Section>();
        var classicMetadata = new Dictionary<string, object>();
        var currentSection = new Section { Name = null, Content = new List<SectionContent>() };
        var stepNumber = 1;

        while (Current.Type != TokenType.EndOfStream)
        {
            // The parser decides what to do based on the type of the current token.
            switch (Current.Type)
            {
                case TokenType.SectionHeader:
                    // When a new section starts, save the previous one and start a new one.
                    if (currentSection.Name != null || currentSection.Content.Count != 0)
                    {
                        sections.Add(currentSection);
                        stepNumber = 1; // Reset step numbering for the new section.
                    }

                    currentSection = new Section
                        { Name = ParseSectionHeader(Current), Content = new List<SectionContent>() };
                    Advance();
                    break;
                case TokenType.Metadata:
                    var (key, value) = ParseClassicMetadata(Current);
                    if (!string.IsNullOrWhiteSpace(key)) classicMetadata[key] = value;
                    Advance();
                    break;
                case TokenType.Note:
                    currentSection.Content.Add(new NoteContent { Value = ParseNote(Current) });
                    Advance();
                    break;
                case TokenType.Newline:
                    // Newlines are now handled within ParseStep()
                    Advance();
                    break;
                default:
                    // Any other token sequence is treated as the start of a recipe step.
                    var step = ParseStep();
                    if (step.Items.Count != 0)
                    {
                        currentSection.Content.Add(new StepContent { Step = step with { Number = stepNumber++ } });
                    }

                    break;
            }
        }

        // Add the last section being processed.
        if (currentSection.Content.Count != 0 || sections.Count == 0)
        {
            sections.Add(currentSection);
        }

        return new SectionsResult(sections, classicMetadata);
    }

    /// <summary>
    /// Parses a section header token to extract the section name.
    /// </summary>
    private string? ParseSectionHeader(Token token)
    {
        var namePart = token.Value.Trim().Trim('=');
        return string.IsNullOrWhiteSpace(namePart) ? null : namePart.Trim();
    }

    /// <summary>
    /// Parses a classic metadata token (e.g., ">> key: value").
    /// </summary>
    private (string key, string value) ParseClassicMetadata(Token token)
    {
        var content = token.Value.Trim()[2..].TrimStart();
        var colonIndex = content.IndexOf(':');
        if (colonIndex == -1) return ("", "");

        var key = content[..colonIndex].Trim();
        var value = content[(colonIndex + 1)..].Trim();

        AddWarning($"Classic metadata format '>> {key}: {value}' is deprecated. Consider using YAML front matter instead.",
            token, ParseErrorType.InvalidMetadata);

        return (key, value);
    }

    /// <summary>
    /// Parses a note token to extract its content.
    /// </summary>
    private string ParseNote(Token token)
    {
        var content = token.Value.Trim()[1..];
        return content.StartsWith(' ') ? content[1..].Trim() : content.Trim();
    }

    /// <summary>
    /// Parses a single recipe step, which consists of a sequence of text and components.
    /// </summary>
    private Step ParseStep()
    {
        var items = new List<Item>();
        var stepEndTokens = new[]
            { TokenType.EndOfStream, TokenType.SectionHeader, TokenType.Metadata, TokenType.Note };

        // Keep parsing items until we hit a token that marks the end of the step.
        while (!stepEndTokens.Contains(Current.Type))
        {
            // Handle newlines specially - check if they should end the step
            if (Current.Type == TokenType.Newline)
            {
                if (ShouldEndStepAtNewline())
                {
                    break; // End the step
                }
                
                if (ShouldContinueStepAfterNewline())
                {
                    items.Add(new TextItem { Value = " " }); // Add space instead of newline
                    Advance(); // Consume the newline
                    continue;
                }
                
                // Default: end the step
                break;
            }
            
            var item = Current.Type switch
            {
                TokenType.At => ShouldParseAsComponent() ? ParseIngredient() : ParseTextWithSymbol(),
                TokenType.Hash => ShouldParseAsComponent() ? ParseCookware() : ParseTextWithSymbol(),
                TokenType.Tilde => ShouldParseAsComponent() ? ParseTimer() : ParseTextWithSymbol(),
                // Any token that doesn't start a component is treated as plain text.
                // This is key to preventing infinite loops.
                _ => ParseText()
            };
            items.Add(item);
        }

        return new Step { Items = ConsolidateTextItems(items) };
    }

    /// <summary>
    /// Checks if we should parse the current symbol as a component or as text.
    /// Returns false if there's a space after the symbol, indicating it should be treated as text.
    /// </summary>
    private bool ShouldParseAsComponent()
    {
        // Look ahead to see if there's a space after the symbol
        var nextToken = PeekNextToken();
        if (nextToken?.Type == TokenType.Text && nextToken.Value.StartsWith(' '))
        {
            return false; // Treat as text
        }
        return true; // Parse as component
    }

    /// <summary>
    /// Parses the current symbol token as plain text.
    /// </summary>
    private Item ParseTextWithSymbol()
    {
        var sb = new StringBuilder();
        sb.Append(Current.Value); // Add the symbol
        Advance(); // Move past the symbol
        
        // Continue parsing as regular text
        var stepEndTokens = ParserConstants.StepEndTokensWithNewline;
        var componentStartTokens = ParserConstants.ComponentStartTokens;

        while (!stepEndTokens.Contains(Current.Type) && !componentStartTokens.Contains(Current.Type))
        {
            sb.Append(Current.Value);
            Advance();
        }

        return new TextItem { Value = sb.ToString() };
    }

    /// <summary>
    /// Parses an ingredient component (e.g., "@flour{1%cup}").
    /// </summary>
    private IngredientItem ParseIngredient()
    {
        var startToken = Current; // The '@' token.
        Advance(); // Consume '@'.

        // Check for space before brace by looking at upcoming tokens
        ValidateNoSpaceBeforeBrace(startToken, "ingredient", ParseErrorType.InvalidIngredientSyntax);

        // An ingredient has a name, an optional quantity/unit, and an optional modifier.
        var name = ReadComponentName();
        
        object quantity = ParserConstants.DefaultQuantity;
        var units = "";
        if (Current.Type == TokenType.LBrace) (quantity, units) = ParseQuantityAndUnits();

        string? note = null;
        if (Current.Type == TokenType.LParen) note = ParseModifier();

        return new IngredientItem { Name = name, Quantity = quantity, Units = units, Note = note };
    }

    /// <summary>
    /// Parses a cookware component (e.g., "#pan{}").
    /// </summary>
    private CookwareItem ParseCookware()
    {
        var startToken = Current; // The '#' token.
        Advance(); // Consume '#'.

        // Check for space before brace by looking at upcoming tokens
        ValidateNoSpaceBeforeBrace(startToken, "cookware", ParseErrorType.InvalidCookwareSyntax);
        
        var name = ReadComponentName();
        
        object quantity = 1;
        var units = "";
        if (Current.Type == TokenType.LBrace)
        {
            (quantity, units) = ParseQuantityAndUnits();
            // If quantity is explicitly empty or "some", it defaults to 1 for cookware.
            if (quantity is string s && (string.IsNullOrWhiteSpace(s) || s == ParserConstants.DefaultQuantity)) quantity = 1;
        }

        string? note = null;
        if (Current.Type == TokenType.LParen) note = ParseModifier();

        return new CookwareItem { Name = name, Quantity = quantity, Units = units, Note = note };
    }

    /// <summary>
    /// Parses a timer component (e.g., "~timer{10%minutes}").
    /// </summary>
    private TimerItem ParseTimer()
    {
        var startToken = Current; // The '~' token.
        Advance(); // Consume '~'.

        // Check for space before brace by looking at upcoming tokens
        ValidateNoSpaceBeforeBrace(startToken, "timer", ParseErrorType.InvalidTimerSyntax);
        
        var name = ReadComponentName();
        
        object quantity = string.Empty;
        var units = "";
        var hadBraces = false;
        if (Current.Type == TokenType.LBrace)
        {
            hadBraces = true;
            (quantity, units) = ParseQuantityAndUnits();
        }

        // A timer is only invalid if it has empty braces ~{}
        // Timers with just a name (like ~rest) are valid according to canonical tests
        if (hadBraces && string.IsNullOrWhiteSpace(name) && (quantity.ToString() == string.Empty || quantity.ToString() == ParserConstants.DefaultQuantity))
        {
            AddSyntaxError("Invalid timer syntax: timer must have either a name or duration", 
                startToken, ParseErrorType.InvalidTimerSyntax, 1);
        }

        return new TimerItem { Name = name, Quantity = quantity, Units = units };
    }

    /// <summary>
    /// Parses a block of plain text by consuming all tokens until a component-start token or the end of a step.
    /// </summary>
    private TextItem ParseText()
    {
        var sb = new StringBuilder();
        var stepEndTokens = ParserConstants.StepEndTokensWithNewline;
        var componentStartTokens = ParserConstants.ComponentStartTokens;

        // This loop consumes ANY token that isn't a special component start or the end of a step.
        while (!stepEndTokens.Contains(Current.Type) && !componentStartTokens.Contains(Current.Type))
        {
            sb.Append(Current.Value);
            Advance();
        }

        return new TextItem { Value = sb.ToString() };
    }

    /// <summary>
    /// A helper method to read a sequence of text tokens until a delimiter is found.
    /// Used for reading names of ingredients, cookware, etc.
    /// </summary>
    private string ReadComponentName()
    {
        var sb = new StringBuilder();
        var stopTokens = ParserConstants.TextStopTokens;

        while (!stopTokens.Contains(Current.Type))
        {
            // If this is a text token, check if it starts with punctuation or Unicode punctuation
            // BUT only if we don't have an upcoming brace (which indicates explicit multi-word syntax)
            // AND we're not inside braces parsing quantities (where spaces should be preserved)
            if (Current.Type == TokenType.Text && !HasUpcomingBrace() && !IsInsideBraceContext())
            {
                var text = Current.Value;
                var wordEnd = FindWordBoundary(text);
                if (wordEnd > 0)
                {
                    sb.Append(text[..wordEnd]);
                    // Update the current token to contain the remaining text
                    if (wordEnd < text.Length)
                    {
                        _tokens[_position] = new Token(TokenType.Text, text[wordEnd..], Current.Line, Current.Column + wordEnd);
                    }
                    else
                    {
                        Advance();
                    }
                    break;
                }
            }
            
            sb.Append(Current.Value);
            Advance();
        }

        return sb.ToString().Trim();
    }
    
    /// <summary>
    /// Checks if we are currently parsing inside brace context (between { and }).
    /// </summary>
    private bool IsInsideBraceContext()
    {
        // Look backwards to see if we recently consumed an LBrace
        // and haven't yet reached the matching RBrace
        var braceDepth = 0;
        for (var i = _position - 1; i >= 0; i--)
        {
            var token = _tokens[i];
            if (token.Type == TokenType.RBrace) braceDepth++;
            else if (token.Type == TokenType.LBrace) 
            {
                braceDepth--;
                if (braceDepth < 0) return true; // We're inside braces
            }
            else if (token.Type is TokenType.Newline or TokenType.At or TokenType.Hash or TokenType.Tilde)
            {
                break; // Stop at line boundaries or new components
            }
        }
        return false;
    }

    /// <summary>
    /// Checks if there's an upcoming LBrace token without advancing the position.
    /// </summary>
    private bool HasUpcomingBrace()
    {
        for (var i = _position; i < _tokens.Count; i++)
        {
            var token = _tokens[i];
            switch (token.Type)
            {
                case TokenType.LBrace:
                    return true;
                case TokenType.Newline or TokenType.EndOfStream or TokenType.At or TokenType.Hash or TokenType.Tilde:
                    return false;
            }
        }
        return false;
    }

    /// <summary>
    /// Finds the end of a word by looking for punctuation or Unicode word boundaries.
    /// </summary>
    private int FindWordBoundary(string text)
    {
        for (var i = 0; i < text.Length; i++)
        {
            var c = text[i];
            // Stop at common punctuation marks or Unicode punctuation, but not slash (/) or decimal point (.) which are used in quantities
            if ((char.IsPunctuation(c) && c != '/' && c != '.') || IsUnicodeWhitespace(c))
            {
                return i;
            }
        }
        return text.Length;
    }

    /// <summary>
    /// Checks if a character is Unicode whitespace.
    /// </summary>
    private bool IsUnicodeWhitespace(char c)
    {
        return char.GetUnicodeCategory(c) == UnicodeCategory.SpaceSeparator;
    }

    /// <summary>
    /// Parses the quantity and units from within curly braces (e.g., "{1%cup}").
    /// </summary>
    private (object quantity, string units) ParseQuantityAndUnits()
    {
        var startToken = Current; // The '{' token.
        Advance(); // Consume '{'.

        var quantityStr = ReadComponentName();
        var units = "";

        if (Current.Type == TokenType.Percent)
        {
            Advance(); // Consume '%'.
            units = ReadComponentName();
        }

        // Check for a closing brace.
        if (Current.Type != TokenType.RBrace)
        {
            AddSyntaxError("Unterminated brace: missing '}'", startToken, ParseErrorType.UnterminatedBrace, 1);
        }
        else Advance(); // Consume '}'.

        return (ParseQuantity(quantityStr, startToken), units);
    }

    /// <summary>
    /// Parses a modifier from within parentheses (e.g., "(diced)").
    /// </summary>
    private string ParseModifier()
    {
        var startToken = Current; // The '(' token.
        Advance(); // Consume '('.
        var contentBuilder = new StringBuilder();
        var depth = 1; // Used to handle nested parentheses correctly.

        while (depth > 0 && Current.Type != TokenType.EndOfStream)
        {
            switch (Current.Type)
            {
                case TokenType.LParen:
                    depth++;
                    break;
                case TokenType.RParen:
                    depth--;
                    break;
            }

            if (depth > 0)
            {
                contentBuilder.Append(Current.Value);
                Advance();
            }
        }

        if (depth > 0)
        {
            AddSyntaxError("Unterminated parenthesis: missing ')'", startToken, ParseErrorType.UnterminatedParenthesis, 1);
        }
        else Advance(); // Consume final ')'.

        return contentBuilder.ToString();
    }

    /// <summary>
    /// Parses the string representation of a quantity into a number or returns it as a string.
    /// </summary>
    private object ParseQuantity(string quantityStr, Token contextToken)
    {
        if (string.IsNullOrWhiteSpace(quantityStr)) return ParserConstants.DefaultQuantity;

        quantityStr = quantityStr.Trim();

        // Handle fractions like "1/2", but preserve unusual formats like "01/2".
        if (!quantityStr.Contains('/'))
        {
            return double.TryParse(quantityStr, out var noSlashDouble) ? noSlashDouble : quantityStr;
        }
        
        var parts = quantityStr.Split('/');
        if (parts.Length != 2 || !double.TryParse(parts[0].Trim(), out var num) || !double.TryParse(parts[1].Trim(), out var den))
        {
            return double.TryParse(quantityStr, out var finalTry) ? finalTry : quantityStr;
        }
        
        if (den == 0)
        {
            AddDiagnostic(new Diagnostic
            {
                Message = "Division by zero in fraction", 
                Line = contextToken.Line,
                Column = contextToken.Column + 1, // Position inside the brace
                Length = quantityStr.Length, 
                Context = quantityStr,
                Type = ParseErrorType.InvalidQuantity, 
                DiagnosticType = DiagnosticType.Error
            });
            return quantityStr;
        }

        // Don't convert fractions that start with 0 (like "01/2") - preserve as text
        var numeratorText = parts[0].Trim();
        if (numeratorText.StartsWith('0') && numeratorText.Length > 1)
        {
            return quantityStr;
        }

        return num / den;
    }

    /// <summary>
    /// A final processing step to merge any consecutive TextItems into a single item
    /// for a cleaner final structure.
    /// </summary>
    private static List<Item> ConsolidateTextItems(List<Item> items)
    {
        if (items.Count <= 1) return items;

        var merged = new List<Item>();
        var textBuffer = new StringBuilder();

        foreach (var item in items)
        {
            if (item is TextItem textItem)
            {
                textBuffer.Append(textItem.Value);
            }
            else
            {
                if (textBuffer.Length > 0)
                {
                    merged.Add(new TextItem { Value = textBuffer.ToString() });
                    textBuffer.Clear();
                }

                merged.Add(item);
            }
        }

        if (textBuffer.Length > 0)
        {
            merged.Add(new TextItem { Value = textBuffer.ToString() });
        }

        return merged;
    }
}