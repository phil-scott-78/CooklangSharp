using System.Collections.Immutable;
using System.Globalization;
using System.Text;
using CooklangSharp.Models;

namespace CooklangSharp.Core;

/// <summary>
/// The Parser consumes the stream of tokens generated by the Lexer and builds the
/// structured, hierarchical representation of the recipe (an Abstract Syntax Tree).
/// </summary>
public class Parser
{
    private ImmutableList<Token> _tokens = ImmutableList<Token>.Empty;
    private readonly ImmutableList<Diagnostic>.Builder _diagnostics = ImmutableList.CreateBuilder<Diagnostic>();
    private int _position;

    /// <summary>
    /// Gets the current token without consuming it.
    /// </summary>
    private Token Current => _position < _tokens.Count ? _tokens[_position] : _tokens[^1];

    /// <summary>
    /// Consumes the current token and moves to the next one.
    /// </summary>
    private void Advance()
    {
        if (_position < _tokens.Count) _position++;
    }

    /// <summary>
    /// The main entry point for the parser. It orchestrates the entire parsing process.
    /// </summary>
    public ParseResult ParseRecipe(string source)
    {
        try
        {
            if (string.IsNullOrEmpty(source))
            {
                return ParseResult.CreateSuccess(new Recipe());
            }

            // 1. Lexing: Convert raw text into a stream of tokens.
            var lexer = new Lexer(source);
            var (tokens, lexerDiagnostics) = lexer.Tokenize();
            _tokens = tokens;
            _diagnostics.AddRange(lexerDiagnostics);
            _position = 0;

            var recipe = new Recipe();

            // 2. Front Matter: This is handled separately as it's not tokenized.
            var (frontMatter, startIndex) = ExtractFrontMatter(source);
            recipe = recipe with { FrontMatter = frontMatter ?? string.Empty };

            // 3. Parsing: Advance past front matter and parse the recipe body.
            while (Current.Type != TokenType.EndOfStream && Current.Line <= startIndex)
            {
                Advance();
            }

            var sectionsResult = ParseSections();
            recipe = recipe with { Sections = sectionsResult.Sections, Metadata = sectionsResult.ClassicMetadata };

            // 4. Result: Return the completed recipe or any errors found.
            var allDiagnostics = _diagnostics.ToImmutable();
            return allDiagnostics.Any(d => d.DiagnosticType == DiagnosticType.Error)
                ? ParseResult.CreateError(allDiagnostics.ToList())
                : ParseResult.CreateSuccess(recipe, allDiagnostics.ToList());
        }
        catch (Exception ex)
        {
            _diagnostics.Add(new Diagnostic
            {
                Message = $"Unexpected parser error: {ex.Message}", Line = Current.Line, Column = Current.Column,
                Length = 1, Context = Current.Value,
                Type = ParseErrorType.Other, DiagnosticType = DiagnosticType.Error
            });
            return ParseResult.CreateError(_diagnostics.ToImmutable().ToList());
        }
    }

    /// <summary>
    /// Manually extracts the YAML front matter block from the start of the source text.
    /// </summary>
    /// <returns>The front matter content and the line number where the recipe content begins.</returns>
    private static (string? frontMatter, int startIndex) ExtractFrontMatter(string source)
    {
        var lines = source.Split(ParserConstants.NewLine);
        if (lines.Length == 0 || lines[0].Trim() != ParserConstants.FrontMatterDelimiter) return (null, 0);

        var frontMatterLines = new List<string>();
        var lineIndex = 1;
        while (lineIndex < lines.Length)
        {
            var line = lines[lineIndex];
            if (line.Trim() == ParserConstants.FrontMatterDelimiter)
            {
                lineIndex++;
                break;
            }

            // Remove any trailing \r to handle CRLF line endings properly
            frontMatterLines.Add(line.TrimEnd('\r'));
            lineIndex++;
        }

        return (string.Join(ParserConstants.NewLine, frontMatterLines), lineIndex);
    }

    private void AddDiagnostic(Diagnostic diagnostic) => _diagnostics.Add(diagnostic);

    /// <summary>
    /// Creates and adds a syntax error diagnostic.
    /// </summary>
    private void AddSyntaxError(string message, Token token, ParseErrorType type, int? length = null)
    {
        AddDiagnostic(new Diagnostic
        {
            Message = message,
            Line = token.Line,
            Column = token.Column,
            Length = length ?? token.Value.Length,
            Context = token.Value,
            Type = type,
            DiagnosticType = DiagnosticType.Error
        });
    }

    /// <summary>
    /// Creates and adds a warning diagnostic.
    /// </summary>
    private void AddWarning(string message, Token token, ParseErrorType type, int? length = null)
    {
        AddDiagnostic(new Diagnostic
        {
            Message = message,
            Line = token.Line,
            Column = token.Column,
            Length = length ?? token.Value.Length,
            Context = token.Value,
            Type = type,
            DiagnosticType = DiagnosticType.Warning
        });
    }

    /// <summary>
    /// Looks ahead at the next token without consuming it.
    /// </summary>
    private Token? PeekNextToken(int offset = 1)
    {
        var targetPosition = _position + offset;
        return targetPosition < _tokens.Count ? _tokens[targetPosition] : null;
    }

    /// <summary>
    /// Determines if a newline should end the current step based on the token that follows.
    /// </summary>
    private bool ShouldEndStepAtNewline()
    {
        var nextToken = PeekNextToken();
        if (nextToken == null) return true; // End of input

        // End step if next token indicates a significant boundary
        return nextToken.Type == TokenType.Newline || // Blank line
               nextToken.Type == TokenType.SectionHeader ||
               nextToken.Type == TokenType.Metadata ||
               nextToken.Type == TokenType.Note ||
               nextToken.Type == TokenType.EndOfStream;
    }

    /// <summary>
    /// Determines if a newline should continue the current step by adding a space separator.
    /// </summary>
    private bool ShouldContinueStepAfterNewline()
    {
        var nextToken = PeekNextToken();

        // Continue step if next token is content
        return nextToken?.Type is TokenType.Text or TokenType.At or TokenType.Hash or TokenType.Tilde;
    }

    /// <summary>
    /// Validates that there is no space before a brace in component syntax.
    /// </summary>
    private void ValidateNoSpaceBeforeBrace(Token startToken, string componentType, ParseErrorType errorType)
    {
        if (Current.Type != TokenType.Text || Current.Value.TrimEnd() == Current.Value || PeekNextToken()?.Type != TokenType.LBrace)
        {
            return;
        }

        var spacePosition = Current.Column + Current.Value.TrimEnd().Length;
        AddDiagnostic(new Diagnostic
        {
            Message = $"Invalid {componentType} syntax: space not allowed before '{{'", 
            Line = startToken.Line,
            Column = spacePosition,
            Length = 1, 
            Context = Current.Value,
            Type = errorType, 
            DiagnosticType = DiagnosticType.Error
        });
    }

    /// <summary>
    /// Parses the main body of the recipe, which is composed of sections.
    /// This is the top-level loop after handling front matter.
    /// </summary>
    private SectionsResult ParseSections()
    {
        var sections = ImmutableList.CreateBuilder<Section>();
        var classicMetadata = ImmutableDictionary.CreateBuilder<string, object>();
        var contentBuilder = ImmutableList.CreateBuilder<SectionContent>();
        string? currentSectionName = null;
        var stepNumber = 1;

        while (Current.Type != TokenType.EndOfStream)
        {
            // The parser decides what to do based on the type of the current token.
            switch (Current.Type)
            {
                case TokenType.SectionHeader:
                    // When a new section starts, save the previous one and start a new one.
                    if (currentSectionName != null || contentBuilder.Count != 0)
                    {
                        sections.Add(new Section { Name = currentSectionName, Content = contentBuilder.ToImmutable() });
                        contentBuilder.Clear();
                        stepNumber = 1; // Reset step numbering for the new section.
                    }

                    currentSectionName = ParseSectionHeader(Current);
                    Advance();
                    break;
                case TokenType.Metadata:
                    var (key, value) = ParseClassicMetadata(Current);
                    if (!string.IsNullOrWhiteSpace(key)) classicMetadata[key] = value;
                    Advance();
                    break;
                case TokenType.Note:
                    contentBuilder.Add(new NoteContent { Value = ParseNote(Current) });
                    Advance();
                    break;
                case TokenType.Newline:
                    // Newlines are now handled within ParseStep()
                    Advance();
                    break;
                default:
                    // Any other token sequence is treated as the start of a recipe step.
                    var step = ParseStep();
                    if (step.Items.Count != 0)
                    {
                        contentBuilder.Add(new StepContent { Step = step with { Number = stepNumber++ } });
                    }

                    break;
            }
        }

        // Add the last section being processed.
        if (contentBuilder.Count != 0 || sections.Count == 0)
        {
            sections.Add(new Section { Name = currentSectionName, Content = contentBuilder.ToImmutable() });
        }

        return new SectionsResult(sections.ToImmutable(), classicMetadata.ToImmutable());
    }

    /// <summary>
    /// Parses a section header token to extract the section name.
    /// </summary>
    private string? ParseSectionHeader(Token token)
    {
        var namePart = token.Value.Trim().Trim('=');
        return string.IsNullOrWhiteSpace(namePart) ? null : namePart.Trim();
    }

    /// <summary>
    /// Parses a classic metadata token (e.g., ">> key: value").
    /// </summary>
    private (string key, string value) ParseClassicMetadata(Token token)
    {
        var content = token.Value.Trim()[2..].TrimStart();
        var colonIndex = content.IndexOf(':');
        if (colonIndex == -1) return ("", "");

        var key = content[..colonIndex].Trim();
        var value = content[(colonIndex + 1)..].Trim();

        AddWarning($"Classic metadata format '>> {key}: {value}' is deprecated. Consider using YAML front matter instead.",
            token, ParseErrorType.InvalidMetadata);

        return (key, value);
    }

    /// <summary>
    /// Parses a note token to extract its content.
    /// </summary>
    private string ParseNote(Token token)
    {
        var content = token.Value.Trim()[1..];
        return content.StartsWith(' ') ? content[1..].Trim() : content.Trim();
    }

    /// <summary>
    /// Parses a single recipe step, which consists of a sequence of text and components.
    /// </summary>
    private Step ParseStep()
    {
        var items = ImmutableList.CreateBuilder<Item>();
        var stepEndTokens = new[]
            { TokenType.EndOfStream, TokenType.SectionHeader, TokenType.Metadata, TokenType.Note };

        // Keep parsing items until we hit a token that marks the end of the step.
        while (!stepEndTokens.Contains(Current.Type))
        {
            // Handle newlines specially - check if they should end the step
            if (Current.Type == TokenType.Newline)
            {
                if (ShouldEndStepAtNewline())
                {
                    break; // End the step
                }
                
                if (ShouldContinueStepAfterNewline())
                {
                    items.Add(new TextItem { Value = " " }); // Add space instead of newline
                    Advance(); // Consume the newline
                    continue;
                }
                
                // Default: end the step
                break;
            }
            
            var item = Current.Type switch
            {
                TokenType.At => ShouldParseAsComponent() ? ParseIngredient() : ParseTextWithSymbol(),
                TokenType.Hash => ShouldParseAsComponent() ? ParseCookware() : ParseTextWithSymbol(),
                TokenType.Tilde => ShouldParseAsComponent() ? ParseTimer() : ParseTextWithSymbol(),
                // Any token that doesn't start a component is treated as plain text.
                // This is key to preventing infinite loops.
                _ => ParseText()
            };
            items.Add(item);
        }

        return new Step { Items = ConsolidateTextItems(items.ToImmutable()) };
    }

    /// <summary>
    /// Checks if we should parse the current symbol as a component or as text.
    /// Returns false if there's a space after the symbol, indicating it should be treated as text.
    /// </summary>
    private bool ShouldParseAsComponent()
    {
        // Look ahead to see if there's a space after the symbol
        var nextToken = PeekNextToken();
        if (nextToken?.Type == TokenType.Text && nextToken.Value.StartsWith(' '))
        {
            return false; // Treat as text
        }
        return true; // Parse as component
    }

    /// <summary>
    /// Parses the current symbol token as plain text.
    /// </summary>
    private Item ParseTextWithSymbol()
    {
        var sb = new StringBuilder();
        sb.Append(Current.Value); // Add the symbol
        Advance(); // Move past the symbol
        
        // Continue parsing as regular text
        var stepEndTokens = ParserConstants.StepEndTokensWithNewline;
        var componentStartTokens = ParserConstants.ComponentStartTokens;

        while (!stepEndTokens.Contains(Current.Type) && !componentStartTokens.Contains(Current.Type))
        {
            sb.Append(Current.Value);
            Advance();
        }

        return new TextItem { Value = sb.ToString() };
    }

    /// <summary>
    /// Parses an ingredient component (e.g., "@flour{1%cup}").
    /// </summary>
    private IngredientItem ParseIngredient()
    {
        var startToken = Current; // The '@' token.
        Advance(); // Consume '@'.

        // Check for space before brace by looking at upcoming tokens
        ValidateNoSpaceBeforeBrace(startToken, "ingredient", ParseErrorType.InvalidIngredientSyntax);

        // An ingredient has a name, an optional quantity/unit, and an optional modifier.
        var name = ReadComponentName();
        
        QuantityValue? quantity = null;
        var units = "";
        if (Current.Type == TokenType.LBrace)
        {
            var (parsedQuantity, parsedUnits) = ParseQuantityAndUnits();
            quantity = parsedQuantity;
            units = parsedUnits;
        }

        string? note = null;
        if (Current.Type == TokenType.LParen) note = ParseModifier();

        return new IngredientItem { Name = name, Quantity = quantity, Units = units, Note = note };
    }

    /// <summary>
    /// Parses a cookware component (e.g., "#pan{}").
    /// </summary>
    private CookwareItem ParseCookware()
    {
        var startToken = Current; // The '#' token.
        Advance(); // Consume '#'.

        // Check for space before brace by looking at upcoming tokens
        ValidateNoSpaceBeforeBrace(startToken, "cookware", ParseErrorType.InvalidCookwareSyntax);
        
        var name = ReadComponentName();
        
        QuantityValue quantity = new RegularQuantity(1);
        var units = "";
        if (Current.Type == TokenType.LBrace)
        {
            var (parsedQuantity, parsedUnits) = ParseQuantityAndUnits();
            units = parsedUnits;
            
            // If quantity is explicitly empty or "some", it defaults to 1 for cookware.
            if (parsedQuantity is null or TextQuantity { Value: "" })
            {
                quantity = new RegularQuantity(1);
            }
            
            else
            {
                quantity = parsedQuantity;
            }
        }

        string? note = null;
        if (Current.Type == TokenType.LParen) note = ParseModifier();

        return new CookwareItem { Name = name, Quantity = quantity, Units = units, Note = note };
    }

    /// <summary>
    /// Parses a timer component (e.g., "~timer{10%minutes}").
    /// </summary>
    private TimerItem ParseTimer()
    {
        var startToken = Current; // The '~' token.
        Advance(); // Consume '~'.

        // Check for space before brace by looking at upcoming tokens
        ValidateNoSpaceBeforeBrace(startToken, "timer", ParseErrorType.InvalidTimerSyntax);
        
        var name = ReadComponentName();
        
        QuantityValue? quantity = new TextQuantity("");
        var units = "";
        var hadBraces = false;
        if (Current.Type == TokenType.LBrace)
        {
            hadBraces = true;
            var (parsedQuantity, parsedUnits) = ParseQuantityAndUnits();
            quantity = parsedQuantity;
            units = parsedUnits;
        }

        // A timer is only invalid if it has empty braces ~{}
        // Timers with just a name (like ~rest) are valid according to canonical tests
        if (hadBraces && string.IsNullOrWhiteSpace(name) && 
            (quantity is null or TextQuantity { Value: "" }))
        {
            AddSyntaxError("Invalid timer syntax: timer must have either a name or duration", 
                startToken, ParseErrorType.InvalidTimerSyntax, 1);
        }

        return new TimerItem { Name = name, Quantity = quantity, Units = units };
    }

    /// <summary>
    /// Parses a block of plain text by consuming all tokens until a component-start token or the end of a step.
    /// </summary>
    private TextItem ParseText()
    {
        var sb = new StringBuilder();
        var stepEndTokens = ParserConstants.StepEndTokensWithNewline;
        var componentStartTokens = ParserConstants.ComponentStartTokens;

        // This loop consumes ANY token that isn't a special component start or the end of a step.
        while (!stepEndTokens.Contains(Current.Type) && !componentStartTokens.Contains(Current.Type))
        {
            sb.Append(Current.Value);
            Advance();
        }

        return new TextItem { Value = sb.ToString() };
    }

    /// <summary>
    /// A helper method to read a sequence of text tokens until a delimiter is found.
    /// Used for reading names of ingredients, cookware, etc.
    /// </summary>
    private string ReadComponentName()
    {
        var sb = new StringBuilder();
        var stopTokens = ParserConstants.TextStopTokens;

        while (!stopTokens.Contains(Current.Type))
        {
            // If this is a text token, check if it starts with punctuation or Unicode punctuation
            // BUT only if we don't have an upcoming brace (which indicates explicit multi-word syntax)
            // AND we're not inside braces parsing quantities (where spaces should be preserved)
            if (Current.Type == TokenType.Text && !HasUpcomingBrace() && !IsInsideBraceContext())
            {
                var text = Current.Value;
                var wordEnd = FindWordBoundary(text);
                if (wordEnd > 0)
                {
                    sb.Append(text[..wordEnd]);
                    // We'll consume the whole token and let the parser handle the remaining text
                    if (wordEnd < text.Length)
                    {
                        // Create a new token list with the modified token
                        _tokens = _tokens.SetItem(_position, new Token(TokenType.Text, text[wordEnd..], Current.Line, Current.Column + wordEnd));
                    }
                    else
                    {
                        Advance();
                    }
                    break;
                }
            }
            
            sb.Append(Current.Value);
            Advance();
        }

        return sb.ToString().Trim();
    }
    
    /// <summary>
    /// Checks if we are currently parsing inside brace context (between { and }).
    /// </summary>
    private bool IsInsideBraceContext()
    {
        // Look backwards to see if we recently consumed an LBrace
        // and haven't yet reached the matching RBrace
        var braceDepth = 0;
        for (var i = _position - 1; i >= 0; i--)
        {
            var token = _tokens[i];
            if (token.Type == TokenType.RBrace) braceDepth++;
            else if (token.Type == TokenType.LBrace) 
            {
                braceDepth--;
                if (braceDepth < 0) return true; // We're inside braces
            }
            else if (token.Type is TokenType.Newline or TokenType.At or TokenType.Hash or TokenType.Tilde)
            {
                break; // Stop at line boundaries or new components
            }
        }
        return false;
    }

    /// <summary>
    /// Checks if there's an upcoming LBrace token without advancing the position.
    /// </summary>
    private bool HasUpcomingBrace()
    {
        for (var i = _position; i < _tokens.Count; i++)
        {
            var token = _tokens[i];
            switch (token.Type)
            {
                case TokenType.LBrace:
                    return true;
                case TokenType.Newline or TokenType.EndOfStream or TokenType.At or TokenType.Hash or TokenType.Tilde:
                    return false;
            }
        }
        return false;
    }

    /// <summary>
    /// Finds the end of a word by looking for punctuation or Unicode word boundaries.
    /// </summary>
    private int FindWordBoundary(string text)
    {
        for (var i = 0; i < text.Length; i++)
        {
            var c = text[i];
            // Stop at common punctuation marks or Unicode punctuation, but not slash (/) or decimal point (.) which are used in quantities
            if ((char.IsPunctuation(c) && c != '/' && c != '.') || IsUnicodeWhitespace(c))
            {
                return i;
            }
        }
        return text.Length;
    }

    /// <summary>
    /// Checks if a character is Unicode whitespace.
    /// </summary>
    private bool IsUnicodeWhitespace(char c)
    {
        return char.GetUnicodeCategory(c) == UnicodeCategory.SpaceSeparator;
    }

    /// <summary>
    /// Parses the quantity and units from within curly braces (e.g., "{1%cup}").
    /// </summary>
    private (QuantityValue? quantity, string units) ParseQuantityAndUnits()
    {
        var startToken = Current; // The '{' token.
        Advance(); // Consume '{'.

        var quantityStr = ReadComponentName();
        var units = "";

        if (Current.Type == TokenType.Percent)
        {
            Advance(); // Consume '%'.
            units = ReadComponentName();
        }

        // Check for a closing brace.
        if (Current.Type != TokenType.RBrace)
        {
            AddSyntaxError("Unterminated brace: missing '}'", startToken, ParseErrorType.UnterminatedBrace, 1);
        }
        else Advance(); // Consume '}'.

        return (ParseQuantity(quantityStr, startToken), units);
    }

    /// <summary>
    /// Parses a modifier from within parentheses (e.g., "(diced)").
    /// </summary>
    private string ParseModifier()
    {
        var startToken = Current; // The '(' token.
        Advance(); // Consume '('.
        var contentBuilder = new StringBuilder();
        var depth = 1; // Used to handle nested parentheses correctly.

        while (depth > 0 && Current.Type != TokenType.EndOfStream)
        {
            switch (Current.Type)
            {
                case TokenType.LParen:
                    depth++;
                    break;
                case TokenType.RParen:
                    depth--;
                    break;
            }

            if (depth > 0)
            {
                contentBuilder.Append(Current.Value);
                Advance();
            }
        }

        if (depth > 0)
        {
            AddSyntaxError("Unterminated parenthesis: missing ')'", startToken, ParseErrorType.UnterminatedParenthesis, 1);
        }
        else Advance(); // Consume final ')'.

        return contentBuilder.ToString();
    }

    /// <summary>
    /// Parses the string representation of a quantity into appropriate QuantityValue type.
    /// </summary>
    private QuantityValue? ParseQuantity(string quantityStr, Token contextToken)
    {
        if (string.IsNullOrWhiteSpace(quantityStr)) 
            return null;

        quantityStr = quantityStr.Trim();

        // Check for mixed fractions like "2 1/3"
        var mixedFractionMatch = System.Text.RegularExpressions.Regex.Match(quantityStr, @"^(\d+)\s+(\d+)/(\d+)$");
        if (mixedFractionMatch.Success)
        {
            if (int.TryParse(mixedFractionMatch.Groups[1].Value, out var whole) &&
                int.TryParse(mixedFractionMatch.Groups[2].Value, out var numerator) &&
                int.TryParse(mixedFractionMatch.Groups[3].Value, out var denominator))
            {
                if (denominator == 0)
                {
                    AddDiagnostic(new Diagnostic
                    {
                        Message = "Division by zero in fraction", 
                        Line = contextToken.Line,
                        Column = contextToken.Column + 1,
                        Length = quantityStr.Length, 
                        Context = quantityStr,
                        Type = ParseErrorType.InvalidQuantity, 
                        DiagnosticType = DiagnosticType.Error
                    });
                    return new TextQuantity(quantityStr);
                }
                return new FractionalQuantity(whole, numerator, denominator);
            }
        }

        // Handle simple fractions like "1/2", but preserve unusual formats like "01/2".
        if (quantityStr.Contains('/'))
        {
            var parts = quantityStr.Split('/');
            if (parts.Length == 2 && double.TryParse(parts[0].Trim(), out var num) && double.TryParse(parts[1].Trim(), out var den))
            {
                if (den == 0)
                {
                    AddDiagnostic(new Diagnostic
                    {
                        Message = "Division by zero in fraction", 
                        Line = contextToken.Line,
                        Column = contextToken.Column + 1,
                        Length = quantityStr.Length, 
                        Context = quantityStr,
                        Type = ParseErrorType.InvalidQuantity, 
                        DiagnosticType = DiagnosticType.Error
                    });
                    return new TextQuantity(quantityStr);
                }

                // Don't convert fractions that start with 0 (like "01/2") - preserve as text
                var numeratorText = parts[0].Trim();
                if (numeratorText.StartsWith('0') && numeratorText.Length > 1)
                {
                    return new TextQuantity(quantityStr);
                }

                // For simple fractions, create FractionalQuantity
                return new FractionalQuantity(0, (int)num, (int)den);
            }
        }
        
        // Try parsing as a regular number
        if (double.TryParse(quantityStr, out var doubleValue))
        {
            return new RegularQuantity(doubleValue);
        }
        
        // Otherwise, it's text
        return new TextQuantity(quantityStr);
    }


    /// <summary>
    /// A final processing step to merge any consecutive TextItems into a single item
    /// for a cleaner final structure.
    /// </summary>
    private static ImmutableList<Item> ConsolidateTextItems(ImmutableList<Item> items)
    {
        if (items.Count <= 1) return items;

        var merged = ImmutableList.CreateBuilder<Item>();
        var textBuffer = new StringBuilder();

        foreach (var item in items)
        {
            if (item is TextItem textItem)
            {
                textBuffer.Append(textItem.Value);
            }
            else
            {
                if (textBuffer.Length > 0)
                {
                    merged.Add(new TextItem { Value = textBuffer.ToString() });
                    textBuffer.Clear();
                }

                merged.Add(item);
            }
        }

        if (textBuffer.Length > 0)
        {
            merged.Add(new TextItem { Value = textBuffer.ToString() });
        }

        return merged.ToImmutable();
    }
}